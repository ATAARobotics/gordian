{"name":"Gordian","tagline":"Alberta Tech Alliance's Scripting Language","body":"# GORDIAN #\r\n===========\r\nLightweight portable scripting language interpreted and run inside of Java with minimal dependencies.\r\n\r\n## Purpose\r\nGordian is designed specifically for [FRC](http://en.wikipedia.org/wiki/FIRST_Robotics_Competition) programming. Fortunately, it is useful for all kinds of different functions.\r\n\r\nGordian is made to be an easy-to-learn scripting language meant for simple programs with normal control flow. It does not natively support threading or objects, but it can be engineered to simulate them.\r\n\r\nGordian is well suited for:\r\n\r\n- Very small linear scripts\r\n- Complex control flow with input and output\r\n- Interpreter of input (ie. configuration files)\r\n\r\nGordian is modelled with inspiration from Python and Lua.\r\n\r\n## Platform\r\nGordian is designed to run on a minimum of Java ME 1.4 on the squawk VM, using the WPILibJ libraries.\r\n\r\n- Gordian for FRC is available at https://github.com/Team4334/gordian\r\n- Gordian for Java SE (or your choice of supported platform) is available at https://github.com/Team4334/gordianSE\r\n\r\n## Project Goals\r\nGordian is a project that aims to help innovate quickly without tinkering embedded code. Its goals are simple:\r\n\r\n- Provide easy, safe syntax for any use\r\n- Avoid any feature creep and stay stable\r\n\r\n## Calling from Java\r\nUse `Gordian.run` to run your script in Java. For more access to variables and elements, create a `Scope` object in the same way as `Gordian.run`, and call `Scope.run(String)` to run your script. The `Scope` object has access to some useful internals of the language.\r\n\r\n# Language specification\r\nGordian follows a semi-strict, dynamic syntax that allows the user many options for scripts. Its syntax is designed to avoid as many possible parsing bugs and unpredictable behaviour.\r\n\r\n# Basics\r\nGordian separates instructions using line breaks (\\n) and semi-colons (;). They are functionally equivalent. For this reason, you can use this notation:\r\n\r\n    def foo(x)\r\n        # instructions\r\n    end\r\n\r\nOr this notation:\r\n\r\n    def foo(x); # instructions; end\r\n    \r\nThey are the same to Gordian.\r\n\r\n## Data\r\nThere are three main data types in Gordian - Numbers, Booleans and Strings. Each is declared as follows\r\n\r\n    # Number\r\n    13.23233\r\n    11\r\n    \r\n    # Boolean\r\n    true\r\n    false\r\n\r\n    # String\r\n    \"Hello World\"\r\n    \"\"\r\n\r\nUnless you work behind the scenes, these are the only data types you will use.\r\n\r\n### Adjustments\r\nTo reverse a boolean, insert a `!` in front of it.\r\n\r\n    !true # is false\r\n    !false # is true\r\n    !!!true # is false\r\n    \r\nTo make a number negative, insert a `-` in front of it.\r\n\r\n    -3 # is -3\r\n    --2 # is 2\r\n\r\n### Calculations\r\nCalculations follow MDASM\r\n\r\n> Multiplication\r\n> Division\r\n> Addition\r\n> Subtraction\r\n> Modulus\r\n> Left > Right\r\n\r\nParentheses **are not supported**. Enforce order with multiple steps!\r\n\r\n    3  * 20 + 2.3 / 1 # is (3 * 20) + (2.3 / 1)\r\n    5 / 6 / 4 # is (5 / 6) / 4\r\n\r\n### Expressions\r\nExpressions evaluate two elements.\r\n\r\n    # `==` and `!=` work on strings and numbers\r\n    \"H\" == \"H\" # is true\r\n    13 != 12.99 # is true\r\n    \r\n    # `+` concatenates two strings together\r\n    \"H\" + \"e\" + \"l\" + \"l\" + \"o\" # is Hello\r\n    \r\n    # `>`, `<`, `>=`, `<=` evaluate numbers\r\n    13 > 12 # is true\r\n    12.5 < 2 # is false\r\n    10 >= 10 # is true\r\n    32 <= 15 # is false\r\n    \r\n    # `&&` and `||` evaluate booleans\r\n    true && false # is false\r\n    true || false # is true\r\n\r\n### Literals\r\nLiterals are direct representations of data written in code.\r\n\r\n**Numbers**\r\n\r\nNumbers are inferred between floating point and integer. If floating point is needed (`x % 1 != 0`), the number will be represented as floating point. Otherwise it will be an integer.\r\n\r\nYou shouldn't worry about differences between floating point and integer. If you need flooring or ceiling arithmetic, create the functions yourself.\r\n\r\n    3 # is functionally equivalent to 3.0\r\n    3.0 # is functionally equivalent to 3\r\n    \r\n**Booleans**\r\n\r\nBoolean literal values are `true` or `false`. Case is ignored (so `True` is still true).\r\n\r\n**Strings**\r\n\r\nStrings are surrounded with quotation marks. Everything in between the quotation marks is regarded as part of the string.\r\n\r\nQuotation marks within quotation marks are part of the string, but can remove spaces from the string.\r\n\r\n    \"Hello \" World\" # is Hello \"World\r\n    \"Hello \"\" World\" # is Hello \"\" World\r\n    \r\nAll spaces after odd (1st, 3rd, 5th, etc.) quotation marks are removed.\r\n\r\n## Variables\r\nVariables store data under a key that can be accessed by the program. Variables have no type, meaning you can easily do this:\r\n\r\n    x = 23\r\n    x = false\r\n    \r\nThis code causes no errors.\r\n\r\n### Declaration\r\nTo declare a variable, use the equals sign. Type is inferred, and the value is interpreted in the current scope of the program.\r\n\r\n    x = \"Hello World\"\r\n\r\n### Creation / Deletion\r\nTo create an \"empty\" value (a plain java `Object` with no discernible qualities), use the `make` keyword.\r\n\r\n    make x\r\n    \r\nThis reserves a space in the scope's memory, allowing you to later declare the variable and preserve its scope.\r\n\r\nTo delete a known variable, use the `del` keyword. This will only delete the *most local* version of the variable, so if two `x` existed (one being shadowed), only the more local one would be removed.\r\n\r\n## Methods\r\nYou can create `UserMethod` objects and add them in `Gordian.run`, and/or define methods inside of your script.\r\n\r\n### Java\r\nSubmit `UserMethod` objects in `Gordian.run` or `Scope` constructor. Here's an example print method\r\n\r\n    new UserMethod(\"print\") {\r\n        public void run(Value[] arguments) {\r\n            System.out.println(arguments[0].getValue());\r\n        }\r\n    }\r\n\r\n### Defined Methods\r\nCreate methods in your code using the `def` keyword.\r\n\r\n    def foo(x)\r\n        # business code here\r\n        # can access x\r\n    end\r\n    \r\nRemember that you cannot call a defined method until the method is defined. Define the method before using it!\r\n\r\n#### Returning\r\nUse the `return` keyword to return a value from a defined method.\r\n\r\n    def spitBack(x)\r\n        return x\r\n    end\r\n\r\nYou can treat `spitBack(x)` as a value now.\r\n\r\n## Control flow\r\nAll blocks are completed with the `end` keyword.\r\n\r\n### If\r\nIf runs if the condition is true\r\n\r\n    if(1 == 1)\r\n        # business code here\r\n    else if (2 != 1)\r\n        # business code here\r\n    else\r\n        # business code here\r\n    end\r\n\r\n### For\r\nFor loops over instructions for an amount of times. The number is evaluated only once, when starting the loop.\r\n\r\n    for (5)\r\n        # business code here\r\n    end\r\n    \r\n### While\r\nWhile loops until its argument is false\r\n\r\n    x  = 0\r\n    while(x < 100)\r\n        x++\r\n    end\r\n\r\n## Scope\r\nEvery method, variable and returning method has a scope. It is only accessible inside of that scope.\r\n\r\n    x = 0\r\n    \r\n    def foo(x)\r\n        # can't access original x, only argument x\r\n        i = 12\r\n        if(true)\r\n            y = 13\r\n            \r\n            def foo2()\r\n            end\r\n        end\r\n        # can't access y, foo2()\r\n    end\r\n    \r\n    # can't access i, y, foo2()\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}